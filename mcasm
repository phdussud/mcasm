#!/usr/bin/python3
# coding:utf-8
#
# Copyright © 2009–2019 Alexios Chouchoulas
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see [http://www.gnu.org/licenses/].

"""
A microcode generator/assembler for Microcode ROMs.

Blank lines are ignored. Comments are marked with a hash (#), which cause
the rest of the line to be ignored. Everything else must be one of three
things, corresponding to these three sections:

* Conditionals: inputs to the Microcode ROM.
* Signals: outputs from the Microcode ROM.
* Microprograms: the contents of the ROM.

==Conditionals==

Conditionals are defined with the 'cond' instruction. E.g:

  cond OP:4

defines an input called OP, and is 4 bits wide. Conditionals form the input of
the MicroROM, and must be defined in order from most-significant to
least-significant address bits.

Conditionals are made up of letters, numbers, and non-whitespace characters
except colons (:) and equal signs (=).

An implicit condition 'uaddr' must always be present. Its bit width may be
freely defined. The uaddr field contains the microinstruction address. This is
also part of the ROM addressing, and is almost always defined to use the
least-significant bits of the full ROM address. (so it will probably be the
last cond encountered in the microcode source)

==Signals==

Signals are the outputs of the microcode ROM. They'll be used to drive the rest
of the CPU. Each signal has a particular bit pattern, which may be defined with
the signal keyword:

  signal /MEMIO        = 0000000000000001
  signal DATA_BUS <- A = 0000000000000010

Signal names may contain any character exept the equals sign (=), notably also
spaces (for legibility). A signal may not start with a minus sign (-).

Each signal is equivalent to a particular bit sring, which is specified in
binary to the right of the equals sign (=). The bitstring may be specified in
traditional form, or with dots (.) or hyphens (-) replacing zeroes (also for
legibility). For example, the above example may be rewritten:

  signal /MEMIO        = ...............1
  signal DATA_BUS <- A = ..............1.

The bitstring can be of arbitrary length, depending on the word width of the
microinstruction.

==Microprograms==

A microprogram starts with the ‘start’ keyword, and a comma-separated list of
conditions.

Each condition is in the form COND=NUM, where COND is one of the CPU's
conditions defined in conds. NUM is the state of that condition signal, which
can be a binary number of appropriate width for the signal (usually just 0 or
1), or X. X is the don't care value.

The microprogram will start at an address in the microcode ROM constructed by
concatenating the values of all the conditions (in their canonical order), plus
a microaddress field of 0. If one or more don't cares are specified as
conditions, the microprogram will repeat in the ROM, to account for the don't
care state. This is a good way to implement the handling of asynchronous
signalling like interrupts, such that the execute part of the instruction works
the same way regardless of the value of IRQ.

Microprogram lines after the 'start' keyword contain one microinstruction per
line. Each microinstruction is specified as a comma-separated list of signals
to set or clear, or the 'hold' keyword.

A signal NAME is set by simply typing NAME. It is cleared by typing -NAME. All
signals set are ORred together, and signals cleared are masked out.

Every microinstruction starts with all signals cleared, so the bitstring is all
zeroes. If the 'hold' keyword is specified, then any signals active in the
previous microinstruction will stay active.

For example:

  cond OP:4
  cond uaadr:3

  signal MEMIO     = ....1
  signal MREAD     = ...1.
  signal MWRITE    = ..1..
  signal MAR <- PC = .1...
  signal IR <- MEM = 1....

  start OP=XXXX # A tiny fetch instruction
    MEMIO, MREAD, MAR <- PC     #
    hold                        # Same as MEMIO, MREAD, MAR <- PC
    hold, -MREAD, IR <- MEM     # Same as MEMIO, MAR <- PC, IR <- MEM

"""

import re
import os
import sys
import array
import pprint
import argparse
import subprocess

__code = """
# This is an example of microcode.

###############################################################################
#
# Conditions: fields embedded in the MicroROM address.
#
###############################################################################

cond RST:1                    # Resetting
cond IRQ:1                    # IRQ request
cond F:1                      # Fetch mode
cond OP:4                     # The opcode field of the IR.
cond I:1                      # The indirection field of the IR.
cond SKIP:1                   # The skip flag from the skip logic.

# The uaddr field of the address is mandatory. This just sets its width.
cond uaddr:4

###############################################################################
#
# Signals: outputs of the MicroROM
#
###############################################################################

signal pc++           = .......................1 # Step the PC

signal mar <- pc      = ......................1. # Latch: MAR = PC
signal mar <- operand = .....................1.. # Latch: MAR = IR.operand
signal mar <- dr      = ....................1... # Latch: MAR = DR

signal ir <- dbus     = ...................1.... # Latch: IR from data bus
signal dr <- dbus     = ..................1..... # Latch: DR from data bus

signal /dab           = .................1...... # Drive Address bus
signal /mem           = ................1....... # Memory access
signal /io            = ...............1........ # Input/Output enable
signal /mr            = ..............1......... # Memory read
signal /mw            = .............1.......... # Memory write

###############################################################################
#
# The Microcode itself.
#
###############################################################################

start IRQ=X, RST=X, F=1, OP=XXXX, I=X, SKIP=X
  MAR <- PC, /DAB, /MEM, /MR       # Drive address bus with PC
  /DAB, /MEM, /MR                  # Wait state (optional?)
  IR <- DBUS, hold                 # Latch data, keep driving.
  -/DAB, -/MEM, -/MR, PC++         # Stop driving bus. Data is now in IR.
#
  MAR <- OPERAND, /DAB, /MEM, /MR  # Drive address bus with OPERAND
  /DAB, /MEM, /MR                  # Wait state
  DR <- DBUS, hold                 # Latch data, keep driving.
  -/DAB, -/MEM, -/MR               # Stop driving. DR = mem[OPERAND].
#
  MAR <- DR, /DAB, /MEM, /MR       # Drive address bus with DR
  /DAB, /MEM, /MR                  # Wait state
  DR <- DBUS, hold                 # Latch data, keep driving.
  -/DAB, -/MEM, -/MR               # Stop driving. DR = mem[mem[OPERAND]].

"""


VERILOG_PREAMBLE = """// -*- verilog -*-
//
// Generated automatically by mcasm, DO NOT EDIT.

`ifdef EXTERNAL_TIMESCALE
  `include "timescale.v"
`else
  `timescale 1ns/1ps
`endif // EXTERNAL_TIMESCALE

`ifndef __MICROCODE_V__
`define __MICROCODE_V__ 1

"""

VERILOG_POSTAMBLE = """
endmodule

`endif // __MICROCODE_V__

// End of file.
"""

MIF_HEADER = """-- Altera Memory Initialisation Format (MIF)
-- Generated automatically by mcasm, do not edit!

DEPTH = %(s)d; -- Number of entries in this ROM
WIDTH = %(w)d; -- Number of data bits per word.
ADDRESS_RADIX = BIN;
DATA_RADIX = BIN;
CONTENT
BEGIN
"""

MIF_FOOTER = """END;

-- End of file.
"""

def die(msg, status=1):
    print("{}: {}".format(sys.argv[0], msg), file=sys.stderr)
    sys.exit(status)


class MicrocodeAssembler(object):

    UINSTR_LENGTH = 24

    def __init__(self, args):
        # Get the parsed command line options.
        self.args = args

        self.want_colour = self.args.color and os.isatty(sys.stdout.fileno())

        # Regular expressions
        self.re_comment = re.compile('(#|//).*$')

        # Internal state.
        self.fname = '?'
        self.lnum = 0
        self.printed_lnum = 0
        self.original_source = ()
        self.lindex = 0
        self.linebuf = ''
        self.source = ()
        self.maxuaddr = 0
        self.uprograms = 0
        self.microcode_pass = 0; 


    def ansi(self, s):
        """Mark up in colour, where available."""
        if not self.want_colour:
            return re.sub('\033\[[^m]+m', '', s)
        return s.replace('\n', '\033[0m\n')


    def read_original_source(self):
        if self.args.verbose:
            f = open(self.fname, 'rt', encoding='utf-8')
            self.original_source = f.readlines()
            f.close()

    def print_original_source(self):
        if self.args.verbose and self.microcode_pass != 1:
            while self.printed_lnum < self.lnum:
                sys.stdout.write(self.original_source[self.printed_lnum])
                self.printed_lnum += 1

    def print_remaining_source(self):
        if self.args.verbose:
            while self.printed_lnum < len(self.original_source):
                sys.stdout.write(self.original_source[self.printed_lnum])
                self.printed_lnum += 1
            print()

    def pansi(self, *args):
        """Print with colour."""
        self.print_original_source()
        print(self.ansi(' '.join(args)))


    def wansi(self, *args):
        """Print with colour."""
        self.print_original_source()
        sys.stdout.write(self.ansi(' '.join(args)))


    def error(self, msg):
        self.print_original_source()
        sys.stderr.write(self.ansi("%s:%d: \033[0;1;31m%s\n" % (self.fname, self.lnum, msg)))
        sys.exit(1)


    def warning(self, msg):
        sys.stderr.write(self.ansi("%s:%d: \033[0;1;33mwarning: %s\n" % (self.fname, self.lnum, msg)))


    def proper_bin(self, x, nb=16):
        return bin(x)[2:].zfill(nb)


    def permute(self, a):
        if a == '':
            yield ''
        elif a[0] == 'x':
            for rest in self.permute(a[1:]):
                yield '0' + rest
                yield '1' + rest
        else:
            for rest in self.permute(a[1:]):
                yield a[0] + rest


    def set_microcode(self, addr, data, notes=''):
        addr = ''.join(addr).lower()
        try:
            self.microcode[int(addr, 2)] = (data, addr)
            return
        except ValueError:
            # There are don't-care values (X) in the address.
            for a in self.permute(addr):
                inta = int(a, 2)
                assert a not in self.microcode
                if a in self.microcode:
                    self.pansi('\033[0;1;35m Overwriting address %s (0x%x).' % (a, inta))
                self.microcode[inta] = (data, addr + notes)


    def idleinstr(self):
        """Return the 'idle' instruction bitfield, i.e. one that does nothing."""
        uinstr = 0
        for instr, bits in self.signals.items():
            # Is this an active low signal?
            selection_index = 1
            if instr.startswith('/'):
                selection_index = 0
            uinstr |= bits[selection_index]
        return uinstr


    def start_statement_reading(self, source):
        self.linebuf = ''
        self.lnum = 0
        self.lindex = 0
        self.source = source

    def mark_current_statement(self):
        self.mark_lindex = self.lindex
        self.mark_lnum = self.lnum
        self.mark_linebuf = self.prev_linebuf

    def restart_marked_statement(self):
        self.lindex = self.mark_lindex
        self.lnum = self.mark_lnum
        self.linebuf = self.mark_linebuf

    def getstatement(self):
        """Read the source file, returning complete statements."""
        while True:
            if ';' in self.linebuf:
                self.prev_linebuf = self.linebuf
                x = self.linebuf.split(';', 1)
                self.linebuf = x[1].strip()
                return x[0].strip()
            elif self.linebuf:
                self.prev_linebuf = self.linebuf;
                self.linebuf = ''
                return self.prev_linebuf

            elif self.lindex < len(self.source):
                line = self.source[self.lindex]
                #print('***', self.lnum, line.rstrip())
                self.lnum += 1
                self.lindex += 1
                if not line:
                    return ''

                # Parse line number magic comments from cpp.
                x = re.findall('^# (\d+) ".+"$', line.strip())
                if x:
                    self.lnum = int(x[0], 10) - 1

                line = self.re_comment.sub('', line)
                line = line.strip()

                self.linebuf += ' ' + line
                continue
            return 0

    def handle_label(self, line, uaddr):
        """Handle labels in statement lines"""
        label, line = line.split(':',1)
        label = label.strip()
        labelname = label.lower()
        if self.microcode_pass == 1:
            addr_field = self.address_field;
            if addr_field:
                shift = addr_field[2]
            else:
                shift = 0
            self.labels[labelname] = (uaddr, uaddr << shift)
            if self.args.mappings:
                self.pansi('# label', label, self.proper_bin(uaddr, 1))
        return line

    def handle_field_value(self, signal):
        """handle the field.value syntax"""
        fieldname, value = signal.split('.',1)

        try:
            fieldname, fieldbits, shift, shiftbit = self.fields[fieldname.lower()]
            #insure that the field bits are all contiguous
            if shiftbit & (shiftbit + 1):
                self.error('the field %s bits are not contiguous ' %fieldname)
            if value.strip()[0].isdigit():
                try:
                    intvalue = int(value, 0)
                except ValueError:
                    self.error("value format incorrect '%s'." % value)
            else:
                val = self.labels.get(value.strip(), None)
                if val is not None:
                    intvalue = val[0] #get the unshifted value
                else:
                    self.error("Unknown label name or value format incorrect '%s'." % value)

            if intvalue > shiftbit:
                self.error('the field %s is too small to contain the value %s' %(fieldname, value))
        except KeyError:
            self.error("Unknown field name '%s'." % fieldname)
        return intvalue << shift
    
    
    
    def process(self, fname, outfname):
        self.fname = fname

        # Initialise conditions.
        self.original_source = ()
        self.conds = list()
        self.condwidths = dict()
        self.signals = dict()
        self.labels = dict()
        self.microcode = dict()
        self.condspecs = []
        self.fields = dict()
        self.address_field = None

        uaddr = 0
        state = 0
        uinstr = 0

        used_signals = set()

        self.read_original_source()

        # Spawn preprocessor.

        try:
            cmd = [self.args.cpp, fname]
            # We'll keep the comments if we're just preprocessing
            # without compiling. Otherwise, let cpp(1) remove them to
            # save us some work.
            if self.args.preprocess:
                cmd.append('-CC')
            source = subprocess.check_output(cmd).decode('utf-8')

        except subprocess.CalledProcessError as e:
            die("{} {} returned exit status {}".format(self.args.cpp, fname, e.returncode))

        except FileNotFoundError as e:
            die("preprocessor {} was not found or is not accessible.".format(self.args.cpp))

        if self.args.preprocess:
            sys.stdout.write(source)
            sys.exit(0)

        self.start_statement_reading(source.splitlines())
        while True:
            line = self.getstatement()
            #end of file check
            if line == 0:
                #we should do the second pass of the last start
                if self.microcode_pass == 1:
                    line = 'start'
                else:
                    break
            line = line.strip()
            # Skip empty lines.
            if not line:
                continue

            if line.startswith('cond'):
                if not re.match('^cond\s+([^:]+)(\s*:\s*(\d+))$', line):
                    self.error('Syntax error parsing "cond" directive.')

                try:
                    condspec = re.findall('cond\s+([^:]+)(\s*:\s*(\d+))$', line).pop()
                except:
                    self.error('Expected "cond SOME-COND [:BITS]"')
                condname = condspec[0].strip()
                condbits = int(condspec[2].strip() or '1')
                if condbits < 1:
                    self.error("Condition '%s' width must be a natural number." % (condname))
                self.conds.append(condname)
                self.condwidths[condname] = condbits
                if self.args.mappings:
                    self.pansi('# cond %s: %d' % (condname, condbits))

            elif line.startswith('field'):
                try:
                    sigspec = re.findall('field\s+(.*\S)\s*=\s*(\S+)', line).pop()
                    fieldname = sigspec[0].strip()
                    if fieldname.startswith('-'):
                        self.error("Field name '%s' starts with a '-', which is not allowed." % (fieldname,))
                    fieldbits = sigspec[1].strip()
                except:
                    self.error('Expected "field SOME-FIELD = MASK-FIELD"')

                try:
                    fieldbits = re.sub('[._-]', '0', fieldbits)
                    fieldbits = re.sub('[X+x]', '1', fieldbits)
                    fieldbits = int(fieldbits, 2)
                    if fieldbits == 0:
                        self.error("Field '%s' contains no bits (zero value)." % fieldname)
                    shift = 0
                    while ((fieldbits >> shift) & 1) == 0:
                        shift +=1
                    field = (fieldname, fieldbits, shift, fieldbits >> shift)
                    self.fields[fieldname.lower()]=(field)
                    if fieldname == 'address':
                        self.address_field = field
                except:
                    self.error('Bit field should be a binary number (. or - are aliases of 0 for readability)')

                if self.args.mappings:
                    self.pansi('# field', fieldname, self.proper_bin(fieldbits, 1))

            elif line.startswith('signal'):
                try:
                    sigspec = line.replace('signal','',1).split ('=', 1)
                    signame = sigspec[0].strip()
                    if signame.startswith('-'):
                        self.error("Signal name '%s' starts with a '-', which is not allowed." % (signame,))
                    values = [ x.strip().lower() for x in sigspec[1].split(',')]
                except:
                    self.error('Expected "signal SOME-SIGNAL = BIT-FIELD OR FIELD.VALUE OR SIGNAL_NAME"')
                sigbits_active_high = 0
                sigbits_active_low = 0 
                for value in values:
                    try:
                        sigbitsval = re.sub('[.-]', '0', value)
                        sigbits_active_high |= int(sigbitsval, 2)
                    except:
                        if '.' in value and value.split('.', 1)[0].strip() in self.fields.keys():
                            sigbits_active_high |= self.handle_field_value(value)
                        elif value in self.signals.keys():
                            negate = 0
                            if value.startswith('/'):
                                negate = 1
                            sigbits_active_high |= self.signals[value][negate]
                            sigbits_active_low |= self.signals[value][1-negate]
                            used_signals = used_signals | set([value])
                        else:
                            self.error('Bit field should be a binary number (. or - are aliases of 0 for readability)')

                self.signals[signame.lower()] = (sigbits_active_high, sigbits_active_low)
                if self.args.mappings:
                    if sigbits_active_high != 0:
                        strp = self.proper_bin(sigbits_active_high, 1)
                    else:
                        strp = ''
                    if sigbits_active_low != 0:
                        strn =   ' /'+ self.proper_bin(sigbits_active_low, 1)
                    else:
                        strn = ''
                    self.pansi('# signal', signame, strp, strn)

            elif line.startswith('start'):
                if self.microcode_pass == 2:
                    self.microcode_pass = 0                    
                if self.microcode_pass == 0:   
                    self.mark_current_statement();
                    self.labels = dict() #labels are local to a microprogram
                    self.microcode_pass = 1
                elif self.microcode_pass == 1:
                    self.restart_marked_statement()
                    self.microcode_pass = 2
                    line = self.getstatement();

                if self.microcode_pass > 1:
                    self.ucodewidth = max(max(max(len(bin(x[0])), len(bin(x[1]))) for x in self.signals.values()) - 2, max(len(bin(x[1])) for x in self.fields.values()) - 2)
                    condre = '(\w+)\s*=\s*([01xX]+)'
                    if not re.match('^start\s+' + condre + '(\s*,\s*' + condre + ')*\s*$', line):
                        print(line)
                        self.error('Syntax error parsing "start" directive.')
                    if 'uaddr' not in self.conds:
                        self.error("The mandatory conditional 'uaddr' has not been defined.")
                    #self.pansi("Starting new microprogram.")
                    self.uprograms += 1
                    self.condspecs = re.findall(condre, line)
                    if not self.condspecs:
                        self.error('No conditions specified')
                    uinstr = self.idleinstr()

                    if self.args.verbose:
                        print()

                uaddr = 0
                state = 1

            else:
                line_to_list = line
                if ':' in line:
                    line = self.handle_label(line, uaddr)
                    if not line:
                        continue
                if state == 0:
                    self.error("Microcode seen before first 'start' keyword.")
                if self.microcode_pass == 2:
                    sigspec = [x.strip() for x in line.split(',')]
                    if 'hold' not in sigspec:
                        uinstr = self.idleinstr()
                    else:
                        sigspec = [x for x in sigspec if x != 'hold']

                    for signal in sigspec:
                        enable = True
                        if signal.startswith('-'):
                            enable = False
                            signal = signal[1:].strip()
                        if '.' in signal:
                            intvalues = (self.handle_field_value(signal), 0)
                        else:
                            used_signals = used_signals | set([signal.lower()])
                            # If it's an active-low signal, negate the semantics.
                            if signal.startswith('/'):
                                enable = not enable
                                pass
                            try:
                                intvalues = self.signals.get(signal.lower(),None)
                                if intvalues == None:
                                    labelvalues = self.labels[signal.lower()]
                                    intvalues = (labelvalues[1],0)
                                    addr_field = self.address_field;
                                    if addr_field:
                                        bits = addr_field[3]
                                        if labelvalues[0] > bits:
                                            self.error('the field "address" is too small to contain the label %s' %(signal))
                                    else:
                                        self.error('the field "address" has not been defined and is used implicitly by label %s' %(signal))
 
                            except KeyError:
                                self.error("Unknown signal name '%s'." % signal)
                        if enable:
                            uinstr |= intvalues[0]
                            uinstr &= ~intvalues[1]
                        else:
                            uinstr &= ~intvalues[0]
                            uinstr |= intvalues[1]


                    # Output the microcode line.
                    #self.pansi(condspecs + [('uaddr', bin(uaddr)[2:])], signals)

                    # Prepare for encoding.
                    d = dict()

                    # Add the microaddress to the conditions.
                    self.condspecs.append(('uaddr', self.proper_bin(uaddr, self.condwidths['uaddr'])))

                    # Turn the conditions into a dictionary.
                    for sig, val in self.condspecs:
                        d[sig] = val # self.proper_bin(val, self.condwidths[sig])

                    # Order the conditions using the order of conds
                    romaddr = list()
                    for c in self.conds:
                        try:
                            assert c in d
                            if len(d[c]) != self.condwidths[c]:
                                self.error("Condition '%s' should specify exactly %d bits, %d seen instead." % (c, self.condwidths[c], len(d[c])))
                            romaddr.append(d[c])
                        except (AssertionError, KeyError):
                            self.error("Missing value for condition '%s'" % c)

                    # Print out the conditions.
                    if self.args.verbose:
                        for c in self.conds:
                            self.wansi('%s:\033[1;32m%s\033[0m ' % (c, d[c]))
                        self.pansi(': \033[1;33m%s\033[0m ; %s' % (self.proper_bin(uinstr, self.ucodewidth), line_to_list.strip()))

                    # Write to the ROM.
                    self.set_microcode(romaddr, uinstr, (' %-40s ' % ' '.join(sigspec)))

                uaddr += 1
                self.maxuaddr = max(self.maxuaddr, uaddr)
                if uaddr > (1 << self.condwidths['uaddr']):
                    uaddr = uaddr & ((1 << self.condwidths['uaddr']) - 1)
                    self.warning("uaddr wraps around to zero after this microinstruction.")

        unused_signals = set(self.signals.keys()) - used_signals
        if unused_signals:
            for a in unused_signals:
                self.warning('Unused signal "%s".' % a)

        if not self.signals:
            die("no output signals declared.")

        #print the end of the original source
        self.print_remaining_source()

        self.totalconds = sum(self.condwidths.values())
        self.romsize = 1 << self.totalconds
        self.ucodewidth = max(max(max(len(bin(x[0])), len(bin(x[1]))) for x in self.signals.values()) - 2, max(len(bin(x[1])) for x in self.fields.values()) - 2)
        self.numroms = (self.ucodewidth + 7) // 8

        if self.args.stats:
            usedbits = 0
            x = max(0, self.maxuaddr - 1)
            # An idiot (me!) wrote this log2() replacement.
            while x:
                usedbits += 1
                x = x >> 1

            self.pansi('\n')
            self.pansi("# Total microprograms:       {:>3}".format(self.uprograms))
            self.pansi("# Biggest microprogram:      {:>3} microinstruction(s)".format(self.maxuaddr))
            self.pansi("# Uaddr width:               {:>3} bits".format(self.condwidths['uaddr']))
            self.pansi("# Uaddr should be:           {:>3} bits wide".format(usedbits))
            self.pansi("# Unneeded uaddr bits:       {:>3} bits".format(self.condwidths['uaddr'] - usedbits))

            self.pansi("# Total address bits needed: {:>3} ({} bytes)".format(self.totalconds, self.romsize))
            self.pansi("# Total data bits needed:    {:>3} ({} ROM ICs in parallel)".format(self.ucodewidth, self.numroms))

        if self.args.dump:
            self.dump()

        # Write the ROM dumps.
        if self.args.bin:
            self.writeroms(outfname)
        if self.args.vhdl:
            self.writeroms_vhdl(outfname)
        if self.args.verilog:
            self.writeroms_verilog(outfname)
            self.writerom_verilog(outfname)
            self.writeroms_verilog_code(outfname)
        if self.args.altera:
            self.writeroms_altera(outfname)
        if self.args.rsar:
            self.writeroms_rsar(outfname)
        if self.args.c:
            self.writeroms_c(outfname)


    def dump(self):
        """Dump the microcode ROMs."""
        idle = self.idleinstr()
        for addr in range(self.romsize):
            data, pattern = self.microcode.get(addr, (idle, '------------'))

            bytedata = list()
            d = data
            for x in range(self.numroms):
                bytedata.insert(0, '%02x' % (d & 0xff))
                d = d >> 8
            bytedata = ' '.join(bytedata)

            self.pansi("%06x: %s ; %s => %s " % (addr, bytedata, pattern,
                                                 self.proper_bin(data, self.ucodewidth)))


    def writeroms_vhdl(self, outfname):
        """Dump the microcode ROMs as a wide VHDL ROM."""
        fname = outfname + ".vhdl"
        print("Writing {}...".format(fname))
        with open(fname, "wt") as f:
            for addr in range(self.romsize):
                data = self.microcode.get(addr, 0)
                bytedata = list()
                try:
                    d = data[0]
                    data = data[0]
                except TypeError:
                    pass
                for x in range(self.numroms):
                    bytedata.insert(0, '%02x' % (d & 0xff))
                    d = d >> 8
                bytedata = ' '.join(bytedata)

                data = self.proper_bin(data, self.ucodewidth)

                f.write("    d <= \"{}\" when a=\"{}\" and oe='0' and ce='0' else\n".format(
                    data, self.proper_bin(addr, self.totalconds)))

            f.write("    d <= \"{}\";\n".format('Z' * self.ucodewidth))


    def writeroms(self, outfname):
        """Write one binary file per microcode ROM."""
        for nrom in range(self.numroms):
            fname = '%s-%02d.bin' % (outfname, nrom)
            shift = 8 * nrom
            mask = 0xff << shift
            print("Writing %s... (mask %x)" % (fname, mask))
            outdata = array.array('B')
            idle = self.idleinstr()
            for addr in range(self.romsize):
                data, pattern = self.microcode.get(addr, (idle, '------------'))
                outdata.append((data & mask) >> shift)
            outdata.tofile(open(fname, 'wb'))


    def writeroms_verilog(self, outfname):
        """Write one binary file per microcode ROM in Verilog binary
        (human-readable binary, that is) format."""
        for nrom in range(self.numroms):
            fname = '%s-%02d.list' % (outfname, nrom)
            shift = 8 * nrom
            mask = 0xff << shift
            print("Writing %s... (mask %x)" % (fname, mask))
            f = open(fname, 'w')
            idle = self.idleinstr()
            for addr in range(self.romsize):
                data, pattern = self.microcode.get(addr, (idle, '------------'))
                f.write('%s // addr=%04x\n' % \
                            (bin((data & mask) >> shift)[2:].zfill(8),
                             addr))
            f.close()

    def writerom_verilog(self, outfname):
        """Write one binary file in Verilog binary
        (human-readable binary, that is) format."""
        fname = '%s.brg' % (outfname)
        print("Writing %s..." % (fname))
        f = open(fname, 'w')
        s = self.romsize
        d = self.totalconds
        w = self.ucodewidth
        idle = self.idleinstr()
        for addr in range(self.romsize):
            data, pattern = self.microcode.get(addr, (idle, '------------'))
            f.write('%s // addr=%s\n' % (self.proper_bin(data, w),self.proper_bin(addr, d)))
        f.close()


    def writeroms_altera(self, outfname):
        """Write a binary file in Altera MIF format."""

        fname = '%s.mif' % (outfname,)
        print("Writing %s..." % (fname,))
        f = open(fname, 'w')
        s = self.romsize
        d = self.totalconds
        w = self.ucodewidth
        idle = self.idleinstr()
        f.write(MIF_HEADER % locals())

        template = "%%0%ds : %%0%ds;\n" % ((d + 3) // 4, (w + 3) // 4)

        for addr in range(self.romsize):
            data, pattern = self.microcode.get(addr, (idle, '------------'))
            f.write(template % (self.proper_bin(addr, d), self.proper_bin(data, w)))
        f.write(MIF_FOOTER % locals())
        f.close()


    def writeroms_rsar(self, outfname):
        """Write a dataset for minimisation by RSAR."""

        d = self.totalconds
        w = self.ucodewidth
        idle = self.idleinstr()

        for cls in range(self.ucodewidth):
            fname = '%s-%03d.rsar' % (outfname, cls)
            print("Writing %s..." % (fname,))
            f = open(fname, 'w')

            for addr in range(self.romsize):
                data, pattern = self.microcode.get(addr, (idle, '------------'))
                x = ' '.join(self.proper_bin(addr, d))
                y = int((data & (1 << cls)) != 0)
                f.write('%s  %d\n' % (x, y))
            f.close()


    def writeroms_verilog_code(self, outfname):
        """Write Verilog code to simulate the microcode ROM."""

        fname = outfname + '.v'
        print("Writing %s..." % (fname,))
        with open(fname, 'wt') as f:
            f.write(VERILOG_PREAMBLE)

            conds = ', '.join('in_' + self.to_v(x, lower=True) for x in self.conds)

            f.write('module Microcode(')
            #f.write(conds)
            #f.write(',\n                 ')
            f.write('cond_vector, control_vector);\n\n')

            #for x in self.conds:
            #    w = self.condwidths[x]
            #    if self.condwidths[x] > 1:
            #        f.write('    input [%d:0] in_%s;\n' % (w - 1, self.to_v(x, lower=True)))
            #    else:
            #        f.write('    input in_%s;\n' % (self.to_v(x, lower=True),))

            f.write('\n    input [%d:0] cond_vector;\n' % (self.totalconds - 1, ))
            f.write('\n    output reg [%d:0] control_vector;\n\n' % (self.ucodewidth - 1, ))

            #f.write('    assign cond_vector = {%s};\n\n' % conds)

            f.write('    always @(cond_vector) begin\n')
            f.write('        case (cond_vector) // synthesis parallel_case\n')

            # Find the default pattern.
            idle = self.idleinstr()
            hist = dict()
            for addr in range(self.romsize):
                data, pattern = self.microcode.get(addr, (idle, '------------'))
                try:
                    hist[data] += 1
                except:
                    hist[data] = 1
            keys = list(hist.keys())
            keys.sort(key=lambda x: hist[x])
            default = keys[-1]

            for addr in range(self.romsize):
                data, pattern = self.microcode.get(addr, (idle, '------------'))
                if data == default:
                    continue
                f.write("            (%d'b%s): control_vector <= %d'b%s;\n" % \
                            (self.totalconds, self.proper_bin(addr, self.totalconds),
                             self.ucodewidth, self.proper_bin(data, self.ucodewidth)))
            f.write("            default: control_vector <= %d'b%s;\n" % \
                        (self.ucodewidth, self.proper_bin(default, self.ucodewidth)))
            f.write('        endcase\n')
            f.write('    end\n')

            f.write(VERILOG_POSTAMBLE)


    C_RESERVED_KEYWORDS = [
        # These are C reserved words

        '_Packed',
        'else',
        'enum',
        'extern',
        'float',
        'for',
        'goto',
        'if',
        'int',
        'long',
        'register',
        'return',
        'short',
        'signed',
        'sizeof',
        'static',
        'struct',
        'switch',
        'typedef',
        'union',
        'unsigned',
        'void',
        'volatile',
        'while',
        'auto',
        'break',
        'case',
        'char',
        'const',
        'continue',
        'default',
        'do',
        'double',
        ]


    VERILOG_RESERVED_KEYWORDS = [
        # These are Verilog reserved words
        'always',
        'assign',
        'automatic',
        'begin',
        'casex',
        'casez',
        'cell',
        'config',
        'deassign',
        'defparam',
        'design',
        'disable',
        'edge',
        'end',
        'endcase',
        'endconfig',
        'endfunction',
        'endgenerate',
        'endmodule',
        'endprimitive',
        'endspecify',
        'endtable',
        'endtask',
        'event',
        'force',
        'forever',
        'fork',
        'function',
        'generate',
        'genvar',
        'ifnone',
        'incdir',
        'include',
        'initial',
        'inout',
        'input',
        'instance',
        'join',
        'liblist',
        'library',
        'localparam',
        'macromodule',
        'module',
        'negedge',
        'noshowcancelled',
        'output',
        'parameter',
        'posedge',
        'primitive',
        'pulsestyle_ondetect',
        'pulsestyle_onevent',
        'reg',
        'release',
        'repeat',
        'scalared',
        'showcancelled',
        'specify',
        'specparam',
        'strength',
        'table',
        'task',
        'tri0',
        'tri1',
        'triand',
        'wand',
        'trior',
        'wor',
        'trireg',
        'use',
        'vectored',
        'wait',
        'while',
        'wire',




        ]

    def to_c(self, x, lower=False):
        """Convert x to a C macro identifier."""
        x = re.sub('^([0-9])', r'N\\1',
                   re.sub('[^A-Za-z0-9_]', '_', x))
        if lower:
            x = x.lower()
        else:
            x = x.upper()

        if x in self.C_RESERVED_KEYWORDS:
            x = x + '_'

        return x

    def to_v(self, x, lower=False):
        """Convert x to a Verilog identifier."""
        if x.startswith('/'):
            x = x[1:] + '_n';

        x = re.sub('^([0-9])', r'N\\1',
                   re.sub('[^A-Za-z0-9_]', '_', x))
        if lower:
            x = x.lower()
        else:
            x = x.upper()

        if x in self.VERILOG_RESERVED_KEYWORDS:
            x = x + '_'

        return x

    def count_set_bits(self, n):
        """Count the bits in a number. Kern. alg"""
        count = 0
        while (n):
            n &= (n-1)
            count+= 1
        return count

    def countbits(self, x):
        """
        Count the bits in a number.

        This is a low-performance way of doing it.
        """
        return len([x for x in bin(x)[2:] if x == '1'])


    def find_field(self, pattern):
        """Return the field with the fewest bits that matches pattern."""
        shortest = None
        shortest_bits = 1e9

        for fieldname, fieldbits, shift, shiftbits in self.fields.values():
            # Does this match the pattern?
            if pattern and pattern & fieldbits == pattern:
                numbits = self.count_set_bits(fieldbits)
                if numbits < shortest_bits:
                    shortest_bits = numbits
                    shortest = (fieldname, fieldbits, shift, shiftbits)
        return shortest


    def writeroms_c(self, outfname):
        """Write a single C99 source code file with the microcode."""
        fname = '%s.h' % outfname
        f = open(fname, 'w')
        print("Writing %s..." % fname)
        idle = self.idleinstr()
        f.write('/* Automatically generated, do not modify! */\n\n')
        f.write('#ifndef __MICROCODE_H__\n')
        f.write('#define __MICROCODE_H__ 1\n')
        f.write('\n\n')

        # Output the conditions
        f.write('typedef struct {\n')
        for cond in self.conds:
            condid = self.to_c(cond, lower=True)
            f.write('        uint32_t %s:%d;\n' % (condid, self.condwidths[cond]))
        f.write('} __microcode_conds_t_msb_1st;\n\n')

        f.write('typedef struct {\n')
        for cond in reversed(self.conds):
            condid = self.to_c(cond, lower=True)
            f.write('        uint32_t %s:%d;\n' % (condid, self.condwidths[cond]))
        f.write('} __microcode_conds_t_lsb_1st;\n\n')

        # Also add a macro to generate uROM addresses based on the conditionals.
        condlist = ', '.join(self.to_c(x, lower=True) for x in self.conds)
        f.write(f'#define MAKE_ADDR({condlist}) ((\\\n')
        shift = 0
        code = list()
        for cond in reversed(self.conds):
            bits = self.condwidths[cond]
            mask = (1 << bits) - 1
            condid = self.to_c(cond, lower=True)
            if shift:
                code.append(f'        ((({condid}) & 0x{mask:x}) << {shift})')
            else:
                code.append(f'        (({condid}) & 0x{mask:x})')
            shift += bits
        f.write(' | \\\n'.join(code) + ') & 0x%x)\n\n' % (self.romsize - 1))

        # Output the fields
        for fieldname, fieldbits, shift, shiftbits in self.fields.values():
            fieldname = self.to_c(fieldname)
            if shift:
                f.write(f'#define GET_{fieldname}(x) ' + \
                             f'(((x) >> 0x{shift:x}) & 0x{shiftbits:x})\n')
            else:
                f.write(f'#define GET_{fieldname}(x) ' + \
                             f'((x) & 0x{shiftbits:x})\n')

        # Output signal definitions.
        comments = ('', ' /* Active low in uROM */')
        sigsort = lambda x: self.signals[x]
        for sig in sorted(self.signals.keys(), key=sigsort):
            patterns = self.signals[sig]
            if sig.startswith('/'):
                invert = 1
                sig = sig[1:].strip()
            else:
                invert = 0
            sig = re.sub('[^A-Za-z0-9_]', '_', sig).upper()
            if (patterns[0] != 0) ^ (patterns[1] != 0):
                if patterns[0] != 0:
                    pattern = patterns[0]
                else:
                    pattern = patterns[1]
                    invert = 1 - invert
                # Find the field this belongs to.
                field = self.find_field(pattern)
                if field:
                    fieldname, fieldbits, shift, shiftbits = field

                    fieldname = re.sub('[^A-Za-z0-9_]', '_', field[0]).upper()
                    pat = ((~pattern if invert == 1 else pattern) >> shift) & shiftbits

                    if fieldbits > 0:
                        f.write(f'#define FIELD_{sig} 0x{pat:x} {comments[invert]}\n')
    
        # Output the signals in a way similar to the conditions.
        sigsort = lambda x: self.signals[x]
        for sig in sorted(self.signals.keys(), key=sigsort):
            patterns = self.signals[sig]

            # If this is an active-low signal, negate the semantics to
            # allow the IS_x macros to make sense.
            ops = ('', '~')
            comments = ('', ' /* Active low in uROM */')
            selection_index = 0
            if sig[0] == '/':
                selection_index = 1
                sig = sig[1:]

            sig = re.sub('[^A-Za-z0-9_]', '_', sig).upper()

            """
            # Output signal definitions.
            f.write(f'#define SIGNAL_{sig} (')
            f.write(f'{ops[selection_index]}0x{(patterns[0] & ~patterns[1]):x}')
            f.write(f'){comments[selection_index]}\n')
            """
            f.write(f'#define IS_{sig}(x) (')
            # Find a field, if one is available.
            field_pos = self.find_field(patterns[0])
            field_neg = self.find_field(patterns[1])
            emitted = False

            if field_pos:
                field = field_pos
                pattern = patterns[0]
                fieldname, fieldbits, shift, shiftbits = field

                fieldname = re.sub('[^A-Za-z0-9_]', '_', field[0]).upper()
                pat = (pattern >> shift) & shiftbits

                f.write(f'(GET_{fieldname}({ops[selection_index]}x) == 0x{pat:x})')
                emitted = True
            elif patterns[0]:
                f.write(f'(({ops[selection_index]}x & 0x{patterns[0]:x}) == 0x{patterns[0]:x})')
                emitted = True
            if field_neg:
                if emitted:
                    f.write(' && ')
                field = field_neg
                pattern = patterns[1]
                fieldname, fieldbits, shift, shiftbits = field

                fieldname = re.sub('[^A-Za-z0-9_]', '_', field[0]).upper()
                pat = (pattern >> shift) & shiftbits

                f.write(f'(GET_{fieldname}({ops[1 - selection_index]}x) == 0x{pat:x})')
            elif patterns[1]:
                if emitted:
                    f.write('&& \\ \n')
                f.write(f'(({ops[1 - selection_index]}x & 0x{patterns[1]:x}) == 0x{patterns[1]:x})')

            f.write(f'){comments[selection_index]}\n')

        f.write('\n\n')

        # Finally, output the microcode itself.

        # First, decide on the most compact datatype.

        width = 1 << self.totalconds
        maxbits = self.ucodewidth
        romsize = self.romsize

        dt = 'unsigned int'
        if maxbits <= 8:
            dt = 'uint8_t'
        elif maxbits <= 16:
            dt = 'uint16_t'
        elif maxbits <= 32:
            dt = 'uint32_t'
        elif maxbits <= 64:
            dt = 'uint64_t'
        else:
            self.warning('uROM is wider than 64 bits. ' +
                         'Using arbitrary uint%d_t for the C code. Good luck.' % maxbits)
        pad = str((maxbits + 3) // 4)

        f.write('/*\n * MICROCODE ROM STARTS HERE\n *\n')
        f.write(' * uROM contains %(romsize)d entries of %(ucodewidth)d bits each.\n */\n'
                % self.__dict__)
        romsize += 1
        f.write('#define MICROCODE_TOCALCONDS %(totalconds)d\n' % self.__dict__)
        f.write('#define MICROCODE_TOTALSIGS %(ucodewidth)d\n' % self.__dict__)
        f.write('#define MICROCODE_ROMSIZE %(romsize)d\n' % self.__dict__)

        f.write('#ifndef WANT_MICROCODE_ROM\n')
        f.write(f'extern const {dt} microcode[{romsize}];\n')
        f.write('#else\n')
        f.write(f'const {dt} microcode[{romsize}]' + ' = {\n')

        for addr in range(self.romsize):
            data, pattern = self.microcode.get(addr, (idle, '------------'))

            bytedata = list()
            d = data
            for x in range(self.numroms):
                bytedata.insert(0, '%02x' % (d & 0xff))
                d = d >> 8
            bytedata = ' '.join(bytedata)

            f.write(('        0x%0' + pad + 'x, /* %06x: %s */\n') % \
                        (data, addr, pattern.rstrip()))
            #f.write(('        0x%0' + pad + 'x,\n') % data)
        f.write('        -1\n};\n\n')
        f.write('#endif /* WANT_MICROCODE_ROM */ \n')
        f.write('\n\n')
        f.write('#endif /* __MICROCODE_H__ */\n')
        f.close()



class MicrocodeAssemblerApp(object):

    CPP_LOCATION = '/usr/bin/cpp'

    def __init__(self):
        # Where's the C Preprocessor?
        self.cpp = os.environ.get('CPP', self.CPP_LOCATION)

        # Command line options
        self.parse_command_line_arguments()


    def run(self):
        for fname in self.args.files:
            try:
                outname = self.args.output or os.path.splitext(fname)[0]
                # Some sanity checks.
                if not os.path.exists(fname):
                    die("{} does not exist, bailing out.".format(fname))
                if not os.path.isfile(fname):
                    die("{} is not a file, bailing out.".format(fname))
                MicrocodeAssembler(self.args).process(fname, outname)

            except IOError as e:
                die("{}: {}".format(fname, str(e)))



    def parse_command_line_arguments(self):
        p = argparse.ArgumentParser(description="Assemble simple microcode into various output files.")
        p.add_argument('-p', '--preprocess', action='store_true',
                       help="""Preprocess to standard output and stop.
                       Useful for debugging preprocessing bugs. As of mcasm 1.4, this also includes
                       any comments in the source file, which in turn is useful for post-processing
                       the microcode to parse To-Do tags etc.""")

        p.add_argument('-o', '--output', metavar='FILENAME',
                       help="""Output object file to FILENAME. Depending on the mode of operation,
                       additional files may be generated with FILENAME as their
                       stem. This only works if a single input file is
                       specified.""")

        p.add_argument('-B', '--no-bin', dest='bin', action='store_false',
                       help="""Do not generate binary 8-bit ROM image files. The default is to generate
                       them.""")

        p.add_argument('-d', '--dump', action='store_true',
                       help="""Print out raw hex values for the entire microcode ROM.""")

        p.add_argument('-m', '--mappings', action='store_true',
                       help="""Print out the symbol to bit mappings for conditions and signals.""")

        p.add_argument('-s', '--stats', action='store_true',
                       help="""Print out statistics about the assembled microcode ROM.""")

        p.add_argument('-V', '--vhdl', action='store_true',
                       help="""Generate FILENAME.vhdl with the ROM as a VHDL code fragment.""")

        p.add_argument('-e', '--verilog', action='store_true',
                       help="""Print out the ROM as one or more verilog binary list files.""")

        p.add_argument('-a', '--altera', action='store_true',
                       help="""Generate the ROM in Altera MIF format.""")

        p.add_argument('-r', '--rsar', action='store_true',
                       help="""Generate an RSAR dataset. RSAR can optimise microcode by finding superfluous
                       conditionals. To simplify the search space, one dataset
                       output will be generated for each output bit in the
                       ROMs. RSAR is available at
                       https://www.bedroomlan.org/projects/rsar.""")

        p.add_argument('-c', '--c', action='store_true',
                       help="""Write out the ROM as C code.""")

        p.add_argument('-v', '--verbose', action='store_true',
                       help="""Print out assembled microcode in human-readable format.""")

        p.add_argument('-C', '--color', action='store_true',
                       help="""Output messages in colour, if possible.""")

        p.add_argument('--cpp', metavar="FILENAME", default=self.cpp,
                       help="""Specify the location of the C Preprocessor (cpp) in your system. The
                       location can also be set in the CPP environment variable.
                       (default: %(default)s)""")

        p.add_argument("files", metavar="INPUT-FILENAME", nargs="+",
                       help="""An input file specifying the microcode to assemble. Multiple files may be
                       provided. They are treated as separate assembly jobs producing separate outputs.""")

        self.args = p.parse_args()

        # Sanity checks
        if self.args.output and len(self.args.files) > 1:
            p.error("-o makes no sense if multiple input files are provided.")


if __name__ == '__main__':
    MicrocodeAssemblerApp().run()


# End of file.
